//! Attribute parsing utilities for `TableModel` derive.

use syn::{DeriveInput, Ident, Type};

/// Configuration extracted from `#[table_model(...)]` attributes
pub struct TableModelAttributes {
    /// The error type for the builder.
    pub error: Option<Type>,
    /// Whether the primary key is a surrogate key.
    pub surrogate_key: bool,
    /// The ancestors of the table.
    pub ancestors: Option<Vec<Type>>,
    /// The root of the ancestor hierarchy.
    pub root: Option<Type>,
}

/// Extract the table module name from the `#[diesel(table_name = ...)]` attribute.
pub fn extract_table_module(input: &DeriveInput) -> Option<syn::Ident> {
    input.attrs.iter().find_map(|attr| {
        if !attr.path().is_ident("diesel") {
            return None;
        }

        let mut table_module = None;
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("table_name") {
                let value = meta.value()?;
                let module_ident: syn::Ident = value.parse()?;
                table_module = Some(module_ident);
                Ok(())
            } else {
                Ok(())
            }
        });
        table_module
    })
}

/// Extract primary key columns from `#[diesel(primary_key = ...)]` attribute.
/// Defaults to "id" if not specified.
pub fn extract_primary_key_columns(input: &DeriveInput) -> Vec<Ident> {
    input
        .attrs
        .iter()
        .find_map(|attr| {
            if !attr.path().is_ident("diesel") {
                return None;
            }

            let mut pk_columns = Vec::new();
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("primary_key") {
                    // Parse primary_key(col1, col2, ...)
                    let content;
                    syn::parenthesized!(content in meta.input);
                    let punct: syn::punctuated::Punctuated<syn::Ident, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&content)?;
                    pk_columns.extend(punct);
                    Ok(())
                } else {
                    Ok(())
                }
            });

            if pk_columns.is_empty() {
                None
            } else {
                Some(pk_columns)
            }
        })
        .unwrap_or_else(|| {
            // Default: if no primary_key attribute, assume "id" is the primary key
            vec![syn::Ident::new("id", proc_macro2::Span::call_site())]
        })
}

/// Extract attributes from `#[table_model(...)]`.
///
/// Supported attributes:
/// - `insertable = "Name"` or `insertable = Name`: Specifies the name of the insertable struct. Defaults to `New{StructName}`.
/// - `error = Type`: Specifies the error type for the builder. Defaults to `std::convert::Infallible` if not present.
/// - `surrogate_key`: Marks the primary key as a surrogate key (generated by DB), excluding it from `NewRecord`.
pub fn extract_table_model_attributes(input: &DeriveInput) -> TableModelAttributes {
    let mut error = None;
    let mut surrogate_key = false;
    let mut ancestors = None;
    let mut root = None;

    for attr in &input.attrs {
        if !attr.path().is_ident("table_model") {
            continue;
        }

        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("error") {
                let value = meta.value()?;
                let ty: syn::Type = value.parse()?;
                error = Some(ty);
            } else if meta.path.is_ident("surrogate_key") {
                surrogate_key = true;
            } else if meta.path.is_ident("ancestors") {
                if meta.input.peek(syn::token::Paren) {
                    let content;
                    syn::parenthesized!(content in meta.input);
                    let punct: syn::punctuated::Punctuated<syn::Ident, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&content)?;
                    // Store ancestor module paths directly without ::table suffix
                    ancestors = Some(
                        punct
                            .into_iter()
                            .map(|module_ident| syn::parse_quote!(#module_ident))
                            .collect(),
                    );
                } else {
                    let value = meta.value()?;
                    let module_ident: syn::Ident = value.parse()?;
                    // Store ancestor module path directly without ::table suffix
                    ancestors = Some(vec![syn::parse_quote!(#module_ident)]);
                }
            } else if meta.path.is_ident("root") {
                let value = meta.value()?;
                let ty: syn::Type = value.parse()?;
                root = Some(ty);
            }
            Ok(())
        });
    }

    TableModelAttributes {
        error,
        surrogate_key,
        ancestors,
        root,
    }
}

/// Check if a field is marked as infallible via `#[table_model(infallible)]` or `#[infallible]`.
pub fn is_field_infallible(field: &syn::Field) -> bool {
    field.attrs.iter().any(|attr| {
        if attr.path().is_ident("infallible") {
            return true;
        }

        if !attr.path().is_ident("table_model") {
            return false;
        }

        let mut infallible = false;
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("infallible") {
                infallible = true;
            }
            Ok(())
        });
        infallible
    })
}

/// Check if a field is marked as mandatory via `#[mandatory(...)]`.
pub fn is_field_mandatory(field: &syn::Field) -> bool {
    field
        .attrs
        .iter()
        .any(|attr| attr.path().is_ident("mandatory"))
}

/// Check if a field is marked as discretionary via `#[discretionary(...)]`.
pub fn is_field_discretionary(field: &syn::Field) -> bool {
    field
        .attrs
        .iter()
        .any(|attr| attr.path().is_ident("discretionary"))
}

/// Extract the referenced table from `#[mandatory(table_name)]` attribute.
/// The table name is now required and must be specified.
pub fn extract_mandatory_table(field: &syn::Field) -> syn::Result<Option<syn::Path>> {
    for attr in &field.attrs {
        if !attr.path().is_ident("mandatory") {
            continue;
        }

        // Parse the table path from the attribute
        let table_path: syn::Path = attr.parse_args().map_err(|_| {
            syn::Error::new_spanned(attr, "Expected table name: #[mandatory(table_name)]")
        })?;

        return Ok(Some(table_path));
    }
    Ok(None)
}

/// Extract the referenced table from `#[discretionary(table_name)]` attribute.
/// The table name is now required and must be specified.
pub fn extract_discretionary_table(field: &syn::Field) -> syn::Result<Option<syn::Path>> {
    for attr in &field.attrs {
        if !attr.path().is_ident("discretionary") {
            continue;
        }

        // Parse the table path from the attribute
        let table_path: syn::Path = attr.parse_args().map_err(|_| {
            syn::Error::new_spanned(attr, "Expected table name: #[discretionary(table_name)]")
        })?;

        return Ok(Some(table_path));
    }
    Ok(None)
}

/// Extract default value from `#[table_model(default = ...)]` attribute on a field.
pub fn extract_field_default_value(field: &syn::Field) -> Option<syn::Expr> {
    let mut default_values = Vec::new();

    for attr in &field.attrs {
        if !attr.path().is_ident("table_model") {
            continue;
        }
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("default") {
                let value = meta.value()?;
                let expr: syn::Expr = value.parse()?;
                default_values.push(expr);
                Ok(())
            } else {
                Ok(())
            }
        });
    }

    if default_values.len() > 1 {
        // We can't easily return an error here because the signature returns Option<Expr>.
        // But we can panic or log. Ideally we should change the signature or handle it in validation.
        // For now, let's just return the first one, and we'll add a separate validation function.
    }

    default_values.into_iter().next()
}

/// Validate field attributes for unsupported configurations.
pub fn validate_field_attributes(field: &syn::Field) -> syn::Result<()> {
    // Check for conflicting mandatory/discretionary attributes
    if is_field_mandatory(field) && is_field_discretionary(field) {
        return Err(syn::Error::new_spanned(
            field,
            "Field cannot be both `#[mandatory]` and `#[discretionary]`",
        ));
    }

    // Check for duplicate mandatory attributes
    let mandatory_count = field
        .attrs
        .iter()
        .filter(|attr| attr.path().is_ident("mandatory"))
        .count();
    if mandatory_count > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Duplicate `#[mandatory]` attribute found. Each field can only have one `#[mandatory]` attribute.",
        ));
    }

    // Check for duplicate discretionary attributes
    let discretionary_count = field
        .attrs
        .iter()
        .filter(|attr| attr.path().is_ident("discretionary"))
        .count();
    if discretionary_count > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Duplicate `#[discretionary]` attribute found. Each field can only have one `#[discretionary]` attribute.",
        ));
    }

    // Check for duplicate infallible attributes (both standalone and nested)
    let mut infallible_count = 0;
    for attr in &field.attrs {
        if attr.path().is_ident("infallible") {
            infallible_count += 1;
        } else if attr.path().is_ident("table_model") {
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("infallible") {
                    infallible_count += 1;
                }
                Ok(())
            });
        }
    }
    if infallible_count > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Duplicate `#[infallible]` or `#[table_model(infallible)]` attribute found. Each field can only have one infallible marker.",
        ));
    }

    // Check for multiple default values
    let mut default_count = 0;
    for attr in &field.attrs {
        if attr.path().is_ident("table_model") {
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("default") {
                    default_count += 1;
                }
                Ok(())
            });
        }
    }
    if default_count > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Multiple `default` values specified for the same field",
        ));
    }

    // Check for unsupported diesel attributes
    for attr in &field.attrs {
        if attr.path().is_ident("diesel") {
            let mut unsupported_attr = None;
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("column_name") {
                    unsupported_attr = Some("column_name");
                } else if meta.path.is_ident("embed") {
                    unsupported_attr = Some("embed");
                } else if meta.path.is_ident("serialize_as") {
                    unsupported_attr = Some("serialize_as");
                } else if meta.path.is_ident("deserialize_as") {
                    unsupported_attr = Some("deserialize_as");
                }
                Ok(())
            });

            if let Some(attr_name) = unsupported_attr {
                return Err(syn::Error::new_spanned(
                    attr,
                    format!("`TableModel` does not support `#[diesel({attr_name} = ...)]`"),
                ));
            }
        }
    }

    // Validate same_as attributes
    // Check that each same_as attribute has proper parentheses and contains valid paths
    for attr in &field.attrs {
        if attr.path().is_ident("same_as") {
            // Ensure the attribute is in the form #[same_as(...)]
            if !matches!(attr.meta, syn::Meta::List(_)) {
                return Err(syn::Error::new_spanned(
                    attr,
                    "Expected `#[same_as(ancestor::column)]` with parentheses",
                ));
            }
        }
    }

    Ok(())
}

/// Extract the `same_as` columns from a field's attributes.
/// Returns a vector of column paths (e.g., `ancestor_table::column_name`).
/// Multiple `#[same_as(...)]` attributes can be specified on a field.
/// Each attribute can contain comma-separated column paths.
pub fn extract_same_as_columns(field: &syn::Field) -> syn::Result<Vec<syn::Path>> {
    let mut same_as_columns = Vec::new();

    for attr in &field.attrs {
        if !attr.path().is_ident("same_as") {
            continue;
        }

        // Parse the column paths from the attribute
        // Format: #[same_as(ancestor_table::column_name, another_table::column)]
        let punct: syn::punctuated::Punctuated<syn::Path, syn::Token![,]> =
            attr.parse_args_with(syn::punctuated::Punctuated::parse_terminated)?;

        same_as_columns.extend(punct);
    }

    Ok(same_as_columns)
}
