//! Attribute parsing utilities for `TableModel` derive.

use syn::{DeriveInput, Ident, Type};

/// Configuration extracted from `#[table_model(...)]` attributes
pub struct TableModelAttributes {
    /// The error type for the builder.
    pub error: Option<Type>,
    /// Whether the primary key is a surrogate key.
    pub surrogate_key: bool,
    /// The ancestors of the table.
    pub ancestors: Option<Vec<Type>>,
    /// The root of the ancestor hierarchy.
    pub root: Option<Type>,
}

/// Extract the table name from the `#[diesel(table_name = ...)]` attribute.
pub fn extract_table_path(input: &DeriveInput) -> Option<syn::Path> {
    input.attrs.iter().find_map(|attr| {
        if !attr.path().is_ident("diesel") {
            return None;
        }

        let mut table_path = None;
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("table_name") {
                let value = meta.value()?;
                let lit: syn::Path = value.parse()?;
                table_path = Some(lit);
                Ok(())
            } else {
                Ok(())
            }
        });
        table_path
    })
}

/// Extract primary key columns from `#[diesel(primary_key = ...)]` attribute.
/// Defaults to "id" if not specified.
pub fn extract_primary_key_columns(input: &DeriveInput) -> Vec<Ident> {
    input
        .attrs
        .iter()
        .find_map(|attr| {
            if !attr.path().is_ident("diesel") {
                return None;
            }

            let mut pk_columns = Vec::new();
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("primary_key") {
                    // Parse primary_key(col1, col2, ...)
                    let content;
                    syn::parenthesized!(content in meta.input);
                    let punct: syn::punctuated::Punctuated<syn::Ident, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&content)?;
                    pk_columns.extend(punct);
                    Ok(())
                } else {
                    Ok(())
                }
            });

            if pk_columns.is_empty() {
                None
            } else {
                Some(pk_columns)
            }
        })
        .unwrap_or_else(|| {
            // Default: if no primary_key attribute, assume "id" is the primary key
            vec![syn::Ident::new("id", proc_macro2::Span::call_site())]
        })
}

/// Extract attributes from `#[table_model(...)]`.
///
/// Supported attributes:
/// - `insertable = "Name"` or `insertable = Name`: Specifies the name of the insertable struct. Defaults to `New{StructName}`.
/// - `error = Type`: Specifies the error type for the builder. Defaults to `std::convert::Infallible` if not present.
/// - `surrogate_key`: Marks the primary key as a surrogate key (generated by DB), excluding it from `NewRecord`.
pub fn extract_table_model_attributes(input: &DeriveInput) -> TableModelAttributes {
    let mut error = None;
    let mut surrogate_key = false;
    let mut ancestors = None;
    let mut root = None;

    for attr in &input.attrs {
        if !attr.path().is_ident("table_model") {
            continue;
        }

        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("error") {
                let value = meta.value()?;
                let ty: syn::Type = value.parse()?;
                error = Some(ty);
            } else if meta.path.is_ident("surrogate_key") {
                surrogate_key = true;
            } else if meta.path.is_ident("ancestors") {
                if meta.input.peek(syn::token::Paren) {
                    let content;
                    syn::parenthesized!(content in meta.input);
                    let punct: syn::punctuated::Punctuated<syn::Type, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&content)?;
                    ancestors = Some(punct.into_iter().collect());
                } else {
                    let value = meta.value()?;
                    let ty: syn::Type = value.parse()?;
                    ancestors = Some(vec![ty]);
                }
            } else if meta.path.is_ident("root") {
                let value = meta.value()?;
                let ty: syn::Type = value.parse()?;
                root = Some(ty);
            }
            Ok(())
        });
    }

    TableModelAttributes {
        error,
        surrogate_key,
        ancestors,
        root,
    }
}

/// Check if a field is marked as infallible via `#[table_model(infallible)]` or `#[infallible]`.
pub fn is_field_infallible(field: &syn::Field) -> bool {
    field.attrs.iter().any(|attr| {
        if attr.path().is_ident("infallible") {
            return true;
        }

        if !attr.path().is_ident("table_model") {
            return false;
        }

        let mut infallible = false;
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("infallible") {
                infallible = true;
            }
            Ok(())
        });
        infallible
    })
}

/// Extract default value from `#[table_model(default = ...)]` attribute on a field.
pub fn extract_field_default_value(field: &syn::Field) -> Option<syn::Expr> {
    let mut default_values = Vec::new();

    for attr in &field.attrs {
        if !attr.path().is_ident("table_model") {
            continue;
        }
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("default") {
                let value = meta.value()?;
                let expr: syn::Expr = value.parse()?;
                default_values.push(expr);
                Ok(())
            } else {
                Ok(())
            }
        });
    }

    if default_values.len() > 1 {
        // We can't easily return an error here because the signature returns Option<Expr>.
        // But we can panic or log. Ideally we should change the signature or handle it in validation.
        // For now, let's just return the first one, and we'll add a separate validation function.
    }

    default_values.into_iter().next()
}

/// Validate field attributes for unsupported configurations.
pub fn validate_field_attributes(field: &syn::Field) -> syn::Result<()> {
    // Check for multiple default values
    let mut default_count = 0;
    for attr in &field.attrs {
        if attr.path().is_ident("table_model") {
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("default") {
                    default_count += 1;
                }
                Ok(())
            });
        }
    }
    if default_count > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Multiple default values specified for the same field",
        ));
    }

    // Check for unsupported diesel attributes
    for attr in &field.attrs {
        if attr.path().is_ident("diesel") {
            let mut unsupported_attr = None;
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("column_name") {
                    unsupported_attr = Some("column_name");
                } else if meta.path.is_ident("embed") {
                    unsupported_attr = Some("embed");
                } else if meta.path.is_ident("serialize_as") {
                    unsupported_attr = Some("serialize_as");
                } else if meta.path.is_ident("deserialize_as") {
                    unsupported_attr = Some("deserialize_as");
                }
                Ok(())
            });

            if let Some(attr_name) = unsupported_attr {
                return Err(syn::Error::new_spanned(
                    attr,
                    format!("TableModel does not support #[diesel({attr_name} = ...)]"),
                ));
            }
        }
    }

    Ok(())
}
