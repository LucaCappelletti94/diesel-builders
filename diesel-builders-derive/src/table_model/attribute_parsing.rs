//! Attribute parsing utilities for `TableModel` derive.

use syn::{DeriveInput, Ident, Type};

/// Configuration extracted from `#[table_model(...)]` attributes
pub struct TableModelAttributes {
    /// The error type for the builder.
    pub error: Option<Type>,
    /// Whether the primary key is a surrogate key.
    pub surrogate_key: bool,
    /// The ancestors of the table.
    pub ancestors: Option<Vec<syn::Path>>,
    /// Default values for ancestor columns.
    pub struct_defaults: Vec<(syn::Path, syn::Expr)>,
    /// Foreign keys defined on the table.
    pub foreign_keys: Vec<ForeignKeyAttribute>,
}

/// Definition of a foreign key.
pub struct ForeignKeyAttribute {
    /// The host columns in the local table.
    pub host_columns: Vec<syn::Ident>,
    /// The target of the foreign key.
    pub referenced_columns: Vec<syn::Path>,
}

/// Extract the table module name from the `#[diesel(table_name = ...)]`
/// attribute.
pub fn extract_table_module(input: &DeriveInput) -> Option<syn::Ident> {
    input.attrs.iter().find_map(|attr| {
        if !attr.path().is_ident("diesel") {
            return None;
        }

        let mut table_module = None;
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("table_name") {
                let value = meta.value()?;
                let module_ident: syn::Ident = value.parse()?;
                table_module = Some(module_ident);
                Ok(())
            } else {
                Ok(())
            }
        });
        table_module
    })
}

/// Extract primary key columns from `#[diesel(primary_key = ...)]` attribute.
/// Defaults to "id" if not specified.
pub fn extract_primary_key_columns(input: &DeriveInput) -> Vec<Ident> {
    input
        .attrs
        .iter()
        .find_map(|attr| {
            if !attr.path().is_ident("diesel") {
                return None;
            }

            let mut pk_columns = Vec::new();
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("primary_key") {
                    // Parse primary_key(col1, col2, ...)
                    let content;
                    syn::parenthesized!(content in meta.input);
                    let punct: syn::punctuated::Punctuated<syn::Ident, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&content)?;
                    pk_columns.extend(punct);
                    Ok(())
                } else {
                    Ok(())
                }
            });

            if pk_columns.is_empty() { None } else { Some(pk_columns) }
        })
        .unwrap_or_else(|| {
            // Default: if no primary_key attribute, assume "id" is the primary key
            vec![syn::Ident::new("id", proc_macro2::Span::call_site())]
        })
}

/// Extract attributes from `#[table_model(...)]`.
///
/// Supported attributes:
/// - `insertable = "Name"` or `insertable = Name`: Specifies the name of the
///   insertable struct. Defaults to `New{StructName}`.
/// - `error = Type`: Specifies the error type for the builder. Defaults to
///   `std::convert::Infallible` if not present.
/// - `surrogate_key`: Marks the primary key as a surrogate key (generated by
///   DB), excluding it from `NewRecord`.
pub fn extract_table_model_attributes(input: &DeriveInput) -> syn::Result<TableModelAttributes> {
    let mut error = None;
    let mut surrogate_key = false;
    let mut ancestors = None;
    let mut struct_defaults = Vec::new();
    let mut foreign_keys = Vec::new();
    let mut parse_errors: Option<syn::Error> = None;

    for attr in &input.attrs {
        if !attr.path().is_ident("table_model") {
            continue;
        }

        let res = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("error") {
                let value = meta.value()?;
                let ty: syn::Type = value.parse()?;
                error = Some(ty);
            } else if meta.path.is_ident("surrogate_key") {
                surrogate_key = true;
            } else if meta.path.is_ident("ancestors") {
                if meta.input.peek(syn::token::Paren) {
                    let content;
                    syn::parenthesized!(content in meta.input);
                    let punct: syn::punctuated::Punctuated<syn::Path, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&content)?;
                    // Store ancestor module paths directly without ::table suffix
                    ancestors = Some(punct.into_iter().collect());
                } else {
                    let value = meta.value()?;
                    let module_ident: syn::Path = value.parse()?;
                    // Store ancestor module path directly without ::table suffix
                    ancestors = Some(vec![module_ident]);
                }
            } else if meta.path.is_ident("default") {
                let content;
                syn::parenthesized!(content in meta.input);
                let path: syn::Path = content.parse()?;
                let _comma: syn::Token![,] = content.parse()?;
                let value: syn::Expr = content.parse()?;
                struct_defaults.push((path, value));
            } else if meta.path.is_ident("foreign_key") {
                let content;
                syn::parenthesized!(content in meta.input);

                // Parse host columns
                let host_columns: Vec<syn::Ident> = if content.peek(syn::token::Paren) {
                    let inner;
                    syn::parenthesized!(inner in content);
                    let punct: syn::punctuated::Punctuated<syn::Ident, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&inner)?;
                    punct.into_iter().collect()
                } else {
                    vec![content.parse()?]
                };

                let _comma: syn::Token![,] = content.parse()?;

                // Parse target
                let referenced_columns = if content.peek(syn::token::Paren) {
                    let inner;
                    syn::parenthesized!(inner in content);
                    let punct: syn::punctuated::Punctuated<syn::Path, syn::Token![,]> =
                        syn::punctuated::Punctuated::parse_terminated(&inner)?;
                    punct.into_iter().collect()
                } else {
                    return Err(syn::Error::new(content.span(), "Expected list of columns"));
                };

                foreign_keys.push(ForeignKeyAttribute { host_columns, referenced_columns });
            }
            Ok(())
        });

        if let Err(e) = res {
            if let Some(existing) = &mut parse_errors {
                existing.combine(e);
            } else {
                parse_errors = Some(e);
            }
        }
    }

    if let Some(e) = parse_errors {
        return Err(e);
    }

    Ok(TableModelAttributes { error, surrogate_key, ancestors, struct_defaults, foreign_keys })
}

/// Check if a field is marked as infallible via `#[table_model(infallible)]` or
/// `#[infallible]`.
pub fn is_field_infallible(field: &syn::Field) -> bool {
    field.attrs.iter().any(|attr| {
        attr.path().is_ident("infallible")
            || (attr.path().is_ident("table_model") && {
                let mut infallible = false;
                let _ = attr.parse_nested_meta(|meta| {
                    if meta.path.is_ident("infallible") {
                        infallible = true;
                    }
                    Ok(())
                });
                infallible
            })
    })
}

/// Check if a field is marked as mandatory via `#[mandatory(...)]`.
pub fn is_field_mandatory(field: &syn::Field) -> bool {
    field.attrs.iter().any(|attr| attr.path().is_ident("mandatory"))
}

/// Check if a field is marked as discretionary via `#[discretionary(...)]`.
pub fn is_field_discretionary(field: &syn::Field) -> bool {
    field.attrs.iter().any(|attr| attr.path().is_ident("discretionary"))
}

/// Extract the referenced table from a triangular relation attribute.
/// The table name is required and must be specified.
fn extract_triangular_table(field: &syn::Field, attr_name: &str) -> syn::Result<Option<syn::Path>> {
    for attr in &field.attrs {
        if !attr.path().is_ident(attr_name) {
            continue;
        }

        // Parse the table path from the attribute
        let table_path: syn::Path = attr.parse_args().map_err(|_| {
            syn::Error::new_spanned(
                attr,
                format!("Expected table name: #[{attr_name}(table_name)]"),
            )
        })?;

        return Ok(Some(table_path));
    }
    Ok(None)
}

/// Extract the referenced table from `#[mandatory(table_name)]` attribute.
/// The table name is now required and must be specified.
pub fn extract_mandatory_table(field: &syn::Field) -> syn::Result<Option<syn::Path>> {
    extract_triangular_table(field, "mandatory")
}

/// Extract the referenced table from `#[discretionary(table_name)]` attribute.
/// The table name is now required and must be specified.
pub fn extract_discretionary_table(field: &syn::Field) -> syn::Result<Option<syn::Path>> {
    extract_triangular_table(field, "discretionary")
}

/// Extract default value from `#[table_model(default = ...)]` attribute on a
/// field.
pub fn extract_field_default_value(field: &syn::Field) -> Option<syn::Expr> {
    let mut default_values = Vec::new();

    for attr in &field.attrs {
        if !attr.path().is_ident("table_model") {
            continue;
        }
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("default") {
                let value = meta.value()?;
                let expr: syn::Expr = value.parse()?;
                default_values.push(expr);
                Ok(())
            } else {
                Ok(())
            }
        });
    }

    if default_values.len() > 1 {
        // We can't easily return an error here because the signature returns
        // Option<Expr>. But we can panic or log. Ideally we should
        // change the signature or handle it in validation.
        // For now, let's just return the first one, and we'll add a separate
        // validation function.
    }

    default_values.into_iter().next()
}

/// Extract the SQL name from `#[table_model(sql_name = "...")]` attribute on a
/// field.
pub fn extract_sql_name(field: &syn::Field) -> Option<String> {
    let mut sql_name = None;

    for attr in &field.attrs {
        if !attr.path().is_ident("table_model") {
            continue;
        }
        let _ = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("sql_name") {
                let value = meta.value()?;
                let lit: syn::LitStr = value.parse()?;
                sql_name = Some(lit.value());
                Ok(())
            } else {
                Ok(())
            }
        });
    }

    sql_name
}

/// Count occurrences of a specific attribute on a field.
fn count_attribute(field: &syn::Field, attr_name: &str) -> usize {
    field.attrs.iter().filter(|attr| attr.path().is_ident(attr_name)).count()
}

/// Count occurrences of infallible markers (both standalone and nested).
fn count_infallible_markers(field: &syn::Field) -> usize {
    let mut count = 0;
    for attr in &field.attrs {
        if attr.path().is_ident("infallible") {
            count += 1;
        } else if attr.path().is_ident("table_model") {
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("infallible") {
                    count += 1;
                }
                Ok(())
            });
        }
    }
    count
}

/// Count occurrences of nested attribute within `#[table_model(...)]`.
fn count_nested_attribute(field: &syn::Field, nested_name: &str) -> usize {
    let mut count = 0;
    for attr in &field.attrs {
        if attr.path().is_ident("table_model") {
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident(nested_name) {
                    count += 1;
                }
                Ok(())
            });
        }
    }
    count
}

/// Validate field attributes for unsupported configurations.
pub fn validate_field_attributes(field: &syn::Field) -> syn::Result<()> {
    // Check for conflicting mandatory/discretionary attributes
    if is_field_mandatory(field) && is_field_discretionary(field) {
        return Err(syn::Error::new_spanned(
            field,
            "Field cannot be both `#[mandatory]` and `#[discretionary]`",
        ));
    }

    // Check for duplicate mandatory attributes
    if count_attribute(field, "mandatory") > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Duplicate `#[mandatory]` attribute found. Each field can only have one `#[mandatory]` attribute.",
        ));
    }

    // Check for duplicate discretionary attributes
    if count_attribute(field, "discretionary") > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Duplicate `#[discretionary]` attribute found. Each field can only have one `#[discretionary]` attribute.",
        ));
    }

    // Check for duplicate infallible attributes (both standalone and nested)
    if count_infallible_markers(field) > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Duplicate `#[infallible]` or `#[table_model(infallible)]` attribute found. Each field can only have one infallible marker.",
        ));
    }

    // Check for multiple default values
    if count_nested_attribute(field, "default") > 1 {
        return Err(syn::Error::new_spanned(
            field,
            "Multiple `default` values specified for the same field",
        ));
    }

    // Check for unsupported diesel attributes
    for attr in &field.attrs {
        if attr.path().is_ident("diesel") {
            let mut unsupported_attr = None;
            let _ = attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("column_name") {
                    unsupported_attr = Some("column_name");
                } else if meta.path.is_ident("embed") {
                    unsupported_attr = Some("embed");
                } else if meta.path.is_ident("serialize_as") {
                    unsupported_attr = Some("serialize_as");
                } else if meta.path.is_ident("deserialize_as") {
                    unsupported_attr = Some("deserialize_as");
                }
                Ok(())
            });

            if let Some(attr_name) = unsupported_attr {
                return Err(syn::Error::new_spanned(
                    attr,
                    format!("`TableModel` does not support `#[diesel({attr_name} = ...)]`"),
                ));
            }
        }
    }

    // Validate same_as attributes
    // Check that each same_as attribute has proper parentheses and contains valid
    // paths
    for attr in &field.attrs {
        if attr.path().is_ident("same_as") {
            // Ensure the attribute is in the form #[same_as(...)]
            if !matches!(attr.meta, syn::Meta::List(_)) {
                return Err(syn::Error::new_spanned(
                    attr,
                    "Expected `#[same_as(ancestor::column)]` with parentheses",
                ));
            }
        }
    }

    Ok(())
}

/// Extract the `same_as` columns from a field's attributes.
/// Returns a vector of vectors, where each inner vector contains the paths from
/// one `#[same_as(...)]` attribute. Format: `#[same_as(path1, path2)]` ->
/// `vec![vec![path1, path2]]` Format: `#[same_as(path1, (path2, path3))]` ->
/// `vec![vec![path1, path2], vec![path1, path3]]`
pub fn extract_same_as_columns(field: &syn::Field) -> syn::Result<Vec<Vec<syn::Path>>> {
    let mut same_as_attributes = Vec::new();

    for attr in &field.attrs {
        if !attr.path().is_ident("same_as") {
            continue;
        }

        // Custom parsing to handle tuples
        let nested_paths = attr.parse_args_with(|input: syn::parse::ParseStream| {
            let mut results = Vec::new();

            // Parse the first path (foreign column)
            let first_path: syn::Path = input.parse()?;

            if input.is_empty() {
                results.push(vec![first_path]);
                return Ok(results);
            }

            input.parse::<syn::Token![,]>()?;

            if input.peek(syn::token::Paren) {
                // Handle tuple: (col1, col2, ...)
                let content;
                syn::parenthesized!(content in input);
                let tuple_paths: syn::punctuated::Punctuated<syn::Path, syn::Token![,]> =
                    syn::punctuated::Punctuated::parse_terminated(&content)?;

                if tuple_paths.is_empty() {
                    return Err(syn::Error::new(
                        content.span(),
                        "Tuple of same_as columns cannot be empty",
                    ));
                }

                for tuple_path in tuple_paths {
                    results.push(vec![first_path.clone(), tuple_path]);
                }
            } else {
                // Handle remaining paths as a list (legacy behavior or simple list)
                let remaining_paths: syn::punctuated::Punctuated<syn::Path, syn::Token![,]> =
                    syn::punctuated::Punctuated::parse_terminated(input)?;

                let mut full_path = vec![first_path];
                full_path.extend(remaining_paths);
                results.push(full_path);
            }

            Ok(results)
        })?;

        same_as_attributes.extend(nested_paths);
    }

    Ok(same_as_attributes)
}
